1. Dado el siguiente programa:
a. Completar el programa principal para que lea información de alumnos (código, nombre, promedio) e informe
la cantidad de alumnos leídos. La lectura finaliza cuando ingresa un alumno con código 0, que no debe
procesarse. Nota: utilizar el módulo leer.
b. Modificar al programa anterior para que, al finalizar la lectura de todos los alumnos, se informe también el
nombre del alumno con mejor promedio.

program Registros;
type
str20 = string[20];
alumno = record
codigo : integer;
nombre : str20;
promedio : real;
end;
procedure leer(var alu : alumno);
begin
  write('Ingrese el codigo del alumno');
  readln(alu.codigo);
  if (alu.codigo <> 0) then begin
    write('Ingrese el nombre del alumno'); 
    readln(alu.nombre);
    write('Ingrese el promedio del alumno'); 
    readln(alu.promedio);
  end;
end;
procedure mejorPromedio(prom:real;nom:str20;var max:real;var maxNom:str20);
begin
  if(prom>max)then begin
    max:=prom;
    maxNom:=nom;
  end;    
end;
{ declaración de variables del programa principal }
var
  a : alumno;
  cant:integer;
  max:real;
  maxNom:str20;
{ cuerpo del programa principal }
begin
  cant:=0;
  max:=-1;
  maxNom:=' ';
  leer(a);
  while(a.codigo<>0)do begin
    cant:=cant+1;
    mejorPromedio(a.promedio,a.nombre,max,maxNom);
    leer(a);
  end;
  writeln('Cantidad de alumnos leidos',cant);
  writeln('Nombre del alumno con meor promedio',maxNom);
end.

2. El registro civil de La Plata ha solicitado un programa para analizar la distribución de casamientos durante el año
2019. Para ello, cuenta con información de las fechas de todos los casamientos realizados durante ese año.
a) Analizar y definir un tipo de dato adecuado para almacenar la información de la fecha de cada casamiento.
b) Implementar un módulo que lea una fecha desde teclado y la retorne en un parámetro cuyo tipo es el definido
en el inciso a).
c) Implementar un programa que lea la fecha de todos los casamientos realizados en 2019. La lectura finaliza al
ingresar el año 2020, que no debe procesarse, e informe la cantidad de casamientos realizados durante los
meses de verano (enero, febrero y marzo) y la cantidad de casamientos realizados en los primeros 10 días de
cada mes. Nota: utilizar el módulo realizado en b) para la lectura de fecha.

program Hello;
type
  rangoD=1..31;
  rangoM=1..12;
  rangoA=2000..2050;
  fecha=record
      dia:rangoD;
      mes:rangoM;
      anio:rangoA;
  end;
procedure leerFecha(var f:fecha);
begin
  write('Ingrese el anio de casamiento');
  readln(f.anio);
  if(f.anio<>2020)then begin
    write('Ingrese el dia');
    readln(f.dia);
    write('Ingrese el mes');
    readln(f.mes);
  end;
end;
function diezDias(dia:rangoD):boolean;
begin
  diezDias:=(dia>=1)and(dia<=10);//la cantidad de casamientos realizados en los primeros 10 dias de cada mes.
end;
function mesDeVerano(mes:rangoM):boolean;
begin
  mesDeVerano:=(mes=1)or(mes=2)or(mes=3);//la cantidad de casamiento realizado durante los meses de verano
end;                                     //(enero,febrero,marzo).
var  
    fec:fecha;
    cantVerano,cantDiez:integer;
begin
  cantVerano:=0;
  cantDiez:=0;
  leerFecha(fec);
  while(fec.anio<>2020)do begin //la lectura finaliza al ingresar el anio 2020
    if(mesDeVerano(fec.mes))then
      cantVerano:=cantVerano+1;
    if(diezDias(fec.dia))then
      cantDiez:=cantDiez+1;
    leerFecha(fec);
  end;
  writeln('Cantidad de casamientos realizados en los primeros 10 dias de cada mes:',cantDiez);
  writeln('Cantidad de casamiento realizado durante los meses de verano:',cantVerano);
end.

3. El Ministerio de Educación desea realizar un relevamiento de las 2400 escuelas primarias de la provincia de Bs. As,
con el objetivo de evaluar si se cumple la proporción de alumnos por docente calculada por la UNESCO para el año
2015 (1 docente cada 23,435 alumnos). Para ello, se cuenta con información de: CUE (código único de
establecimiento), nombre del establecimiento, cantidad de docentes, cantidad de alumnos, localidad. Se pide
implementar un programa que procese la información y determine:
● Cantidad de escuelas de La Plata con una relación de alumnos por docente superior a la sugerida por UNESCO.
● CUE y nombre de las dos escuelas con mejor relación entre docentes y alumnos.
El programa debe utilizar:
a) Un módulo para la lectura de la información de la escuela.
b) Un módulo para determinar la relación docente-alumno (esa relación se obtiene del cociente entre la cantidad
de alumnos y la cantidad de docente.

program Hello;
const
    escuelas=3;//2400
    propUNESCO=1/23435;//proporción de alumnos por docente calculada por la UNESCO
type 
    cadena30=string[30];
    establecimiento=record
            CUE:integer;
            nom:cadena30;
            cantDoc:integer;
            cantAlu:integer;
            localidad:cadena30;
    end;
procedure leerEstablecimiento(var e:establecimiento);
begin
  write('Ingrese el CUE:');
  readln(e.CUE);
  write('Ingrese el nombre de establecimiento:');
  readln(e.nom);
  write('Ingrese la cantidad de docente:');
  readln(e.cantDoc);
  write('Ingrese la cantidad de alumnos:');
  readln(e.cantAlu);
  write('Ingrese la localidad:');
  readln(e.localidad);
end;
function cumple(localidad:cadena30;relacion:real):boolean;
begin
  cumple:=(localidad='La Plata')and(relacion>propUNESCO);//Cantidad de escuelas de La Plata con una relación de
end;                                                     //alumnos por docente superior a la sugerida por UNESCO.
procedure escMejorRelacion(cueAct:integer;nomAct:cadena30;relacion:real;var max1,max2:real;var cue1,cue2:integer;var nom1,nom2:cadena30);
begin
  if(relacion>max1)then begin
    max2:=max1;
    cue2:=cue1;
    nom2:=nom1;
    max1:=relacion;
    cue1:=cueAct;
    nom1:=nomAct;
  end
  else if(relacion>max2)then begin
    max2:=relacion;
    cue2:=cueAct;
    nom2:=nomAct;
  end;
end;
function relacDocAlu(cantDoc:integer;cantAlu:integer):real;
begin
  relacDocAlu:=(cantDoc/cantAlu);
end;
var est:establecimiento;
    i,cantEsc,cue1,cue2:integer;
    relacion,max1,max2:real;
    nom1,nom2:cadena30;
begin
  cantEsc:=0;
  max1:=-1;
  for i:=1 to escuelas do begin
    leerEstablecimiento(est);
    relacion:=relacDocAlu(est.cantDoc,est.cantAlu);
    if(cumple(est.localidad,relacion))then
      cantEsc:=cantEsc+1;
    escMejorRelacion(est.CUE,est.nom,relacion,max1,max2,cue1,cue2,nom1,nom2);
  end;
  writeln('Cantidad de escuelas de La Plata con una relación de alumnos por docente superior a la sugerida por UNESCO:', cantEsc);
  writeln('CUE y nombre de las dos escuelas con mejor relación entre docentes y alumnos:',cue1,nom1,'y',cue2,nom2);
end.

4. Una compañía de telefonía celular debe realizar la facturación mensual de sus 9300 clientes con planes de
consumo ilimitados (clientes que pagan por lo que consumen). Para cada cliente se conoce su código de cliente y
cantidad de líneas a su nombre. De cada línea se tiene el número de teléfono, la cantidad de minutos consumidos
y la cantidad de MB consumidos en el mes. Se pide implementar un programa que lea los datos de los clientes de
la compañía e informe el monto total a facturar para cada uno. Para ello, se requiere:
a. Realizar un módulo que lea la información de una línea de teléfono.
b. Realizar un módulo que reciba los datos de un cliente, lea la información de todas sus líneas (utilizando el
módulo desarrollado en el inciso a. ) y retorne la cantidad total de minutos y la cantidad total de MB a facturar
del cliente.
Nota: para realizar los cálculos tener en cuenta que cada minuto cuesta $3,40 y cada MB consumido cuesta $1,35.

program Hello;
const
    CLIMAX=3;//9300
    PMIN=3.40;
    PMB=1.35;
type
    cliente=record
       codigo:integer;
       cantLineas:integer;
    end;
    linea=record
       numTel:integer;
       cantMinCons:real;
       cantMBCons:real;
    end;
    
procedure leerCliente(var c:cliente);
begin
  write('Codigo de cliente:');
  readln(c.codigo);
  write('Cantidad de lineas:');
  readln(c.cantLineas);
end;
procedure leerLinea(var l:linea);
begin
  write('Numero de telefono:');
  readln(l.numTel);
  write('Minutos consuidos:');
  readln(l.cantMinCons);
  write('MB consumidos:');
  readln(l.cantMBCons);
end;
procedure procesar(c:cliente;var total,totalMB:real);
var l:linea;i:integer;
begin
  total:=0;
  totalMB:=0;
  leerCliente(c);
  for i:=1 to c.cantLineas do begin
    leerLinea(l);
    total:=total+l.cantMinCons;
    totalMB:=totalMB+l.cantMBCons;
  end;
end;
var cli:cliente;
    i:integer;
    total,totalMB,montoTotal,precioTotalMin,precioTotalMB:real;
begin
  for i:=1 to CLIMAX do begin
    procesar(cli,total,totalMB);
    precioTotalMin:=total*PMIN;
    precioTotalMB:=totalMB*PMB;
    montoTotal:=precioTotalMin+precioTotalMB;
    writeln ('Cliente',i,'el monto total a facturar es',montoTotal:4:2);
  end;
end.

5. Realizar un programa que lea información de autos que están a la venta en una concesionaria. De cada auto se lee:
marca, modelo y precio. La lectura finaliza cuando se ingresa la marca “ZZZ” que no debe procesarse. La
información se ingresa ordenada por marca. Se pide calcular e informar:
a. El precio promedio por marca.
b. Marca y modelo del auto más caro.

program Hello;
type 
    cadena20=string[20];
    auto=record
        marca:cadena20;
        modelo:cadena20;
        precio:real;
    end;
procedure leerAuto(var a:auto);
begin
  write('Ingrese la marca:');
  readln(a.marca);
  if(a.marca<>'ZZZ')then begin
    write('Ingrese el modelo:');
    readln(a.modelo);
    write('Ingrese el precio:');
    readln(a.precio);
  end;    
end;
procedure masCaro(precio:real;marca,modelo:cadena20;var max:real;var maxMarca,maxModelo:cadena20);
begin
  if(precio>max)then begin
    max:=precio;
    maxMarca:=marca;
    maxModelo:=modelo;
  end;
end;
var  
   a:auto;
   cantAutos:integer;
   max,sumaPrecios,precioPromedio:real;
   maxMar,MaxMod,marcaActual:cadena20;
begin
  max:=-1;
  leerAuto(a);
  while(a.marca<>'ZZZ')do begin
    marcaActual:=a.marca;
    cantAutos:=0;
    sumaPrecios:=0;
    precioPromedio:=0;
    while(a.marca<>'ZZZ')and(marcaActual=a.marca)do begin
      cantAutos:=cantAutos+1;
      sumaPrecios:=sumaPrecios+a.precio;
      masCaro(a.precio,a.marca,a.modelo,max,maxMar,MaxMod);
      leerAuto(a);
    end;
    precioPromedio:=sumaPrecios/cantAutos;
    writeln('Marca',marcaActual,'precio promedio',precioPromedio:4:2);
  end;
  writeln('Marca y modelo del auto mas caro:',maxMar,' ',MaxMod);
end.

6. Una empresa importadora de microprocesadores desea implementar un sistema de software para analizar la
información de los productos que mantiene actualmente en stock. Para ello, se conoce la siguiente información de
los microprocesadores: marca (Intel, AMD, NVidia, etc), línea (Xeon, Core i7, Opteron, Atom, Centrino, etc.),
cantidad de cores o núcleos de procesamiento (1, 2, 4, 8), velocidad del reloj (medida en Ghz) y tamaño en
nanómetros (nm) de los transistores (14, 22, 32, 45, etc.). La información de los microprocesadores se lee de
forma consecutiva por marca de procesador y la lectura finaliza al ingresar un procesador con 0 cores (que no
debe procesarse). Se pide implementar un programa que lea información de los microprocesadores de la empresa
importadora e informe:
● Marca y línea de todos los procesadores de más de 2 cores con transistores de a lo sumo 22 nm.
● Las dos marcas con mayor cantidad de procesadores con transistores de 14 nm.
● Cantidad de procesadores multicore (de más de un core) de Intel o AMD, cuyos relojes alcancen velocidades de
al menos 2 Ghz.

program Hello;
type
  cadena20=string[20];
  microprocesador=record
        marca:cadena20;
        linea:cadena20;
        nucleos:integer;
        velocidad:real;
        tamanio:integer;
  end;
procedure leerMicroprocesador(var m:microprocesador);
begin
  with m do begin
    write('Ingrese cantidad de cores:');
    readln(nucleos);
    if(nucleos<>0)then begin
      write('Ingrese la marca:');
      readln(marca);
      write('Ingrese la linea:');
      readln(linea);
      write('Ingrese la velocidad de reloj:');
      readln(velocidad);
      write('Ingrese el tamanio de transitores:');
      readln(tamanio);
    end;
  end;
end;
function masDe2CoresTrans22(m:microprocesador):boolean;
begin
  masDe2CoresTrans22:=(m.nucleos>2)and(m.tamanio<=22);
end;
procedure dosMaximos(cant:integer;marca:cadena20;var max1,max2:integer;var maxMarca1,maxMarca2:cadena20);
begin
  if(cant>max1)then begin
    max2:=max1;
    maxMarca2:=maxMarca1;
    max1:=cant;
    maxMarca1:=marca;
  end
  else if(cant>max2)then begin
    max2:=cant;
    maxMarca2:=marca;
  end;
end;
function multicore(m:microprocesador):boolean;
begin
  multicore:=(m.nucleos>1)and(m.marca='AMD')or(m.marca='Intel')and(m.velocidad>=2);
end;
var m:microprocesador;
    marcaActual,maxMarca1,maxMarca2:cadena20;
    cant14mn,cantMulticore,max1,max2:integer;
begin
  max1:=-1;
  maxMarca1:='';
  maxMarca2:='';
  cantMulticore:=0;
  leerMicroprocesador(m);
  while(m.nucleos<>0)do begin
    marcaActual:=m.marca;
    cant14mn:=0;
    while(m.nucleos<>0)and(marcaActual=m.marca)do begin
      if(masDe2CoresTrans22(m))then
        writeln('El procesador ',m.marca,' linea ',m.linea,' tiene mas de 2 cores con transitores de a lo sumo 22nm');
      if(m.tamanio=14)then
        cant14mn:=cant14mn+1;
      if(multicore(m))then begin
        cantMulticore:=cantMulticore+1;
      leerMicroprocesador(m);
      end;
      dosMaximos(cant14mn,m.marca,max1,max2,maxMarca1,maxMarca2);
    end;
  end;
  writeln('Las dos marcas con mayor cantidad de procesadores con transistores de 14 nm:',maxMarca1,' y ',maxMarca2);
  writeln('Cantidad de procesadores multicore de Intel o AMD, cuyos relojes alcancen velocidades de al menos 2 Ghz es:',cantMulticore);
end.

7. Realizar un programa que lea información de centros de investigación de Universidades Nacionales. De cada
centro se lee su nombre abreviado (ej. LIDI, LIFIA, LINTI), la universidad a la que pertenece, la cantidad de
investigadores y la cantidad de becarios que poseen. La información se lee de forma consecutiva por universidad y
la lectura finaliza al leer un centro con 0 investigadores, que no debe procesarse. Informar:
● Cantidad total de centros para cada universidad.
● Universidad con mayor cantidad de investigadores en sus centros.
● Los dos centros con menor cantidad de becarios.

program Hello;
type 
    cadena30=string[30];
    centro=record
        nombre:cadena30;
        universidad:cadena30;
        cantInvest:integer;
        cantBecarios:integer;
    end;
procedure leerCentro(var c:centro);
begin
  write('Ingrese la cantidad de investigadores:');
  readln(c.cantInvest);
  if(c.cantInvest<>0)then begin
    write('Ingrese el centro:');
    readln(c.nombre);
    write('Ingrese la universidad:');
    readln(c.universidad);
    write('Ingrese la cantidad de becarios:');
    readln(c.cantBecarios);
  end;
end;
procedure mayorCantInvest(cantInvest:integer;universidad:cadena30;var max:integer;var univMax:cadena30);
begin
  if(cantInvest>max)then begin
    max:=cantInvest;
    univMax:=universidad;
  end;
end;
procedure menorCantBecarios(cantBecarios:integer;nom:cadena30;var min1,min2:integer;var minNon1,minNom2:cadena30);
begin
  if(cantBecarios<min1)then begin
    min2:=min1;
    minNom2:=minNon1;
    min1:=cantBecarios;
    minNon1:=nom;
  end
  else if(cantBecarios<min2)then begin
    min2:=cantBecarios;
    minNom2:=nom;
  end;
end;
var c:centro;
    min1,min2,cantTotal,max:integer;
    minNon1,minNom2,univMax,univActual:cadena30;
begin
  min1:=999;
  max:=-1;
  univMax:='';
  minNon1:='';
  leerCentro(c);
  while(c.cantInvest<>0)do begin
    univActual:=c.universidad;
    cantTotal:=0;
    while(c.cantInvest<>0)and(univActual=c.universidad)do begin
      cantTotal:=cantTotal+1;
      menorCantBecarios(c.cantBecarios,c.nombre,min1,min2,minNon1,minNom2);
      leerCentro(c);
    end;
    mayorCantInvest(c.cantInvest,c.universidad,max,univMax);
    writeln('Cantidad total de centro para la universidad ',univActual,' es ',cantTotal);
  end;
  writeln('Universidad con mayor cantidad de investigadores en su centro',univMax);
  writeln('Los dos centros con menor cantidad de becarios:', minNon1,' y ',minNom2);
end.

8. La Comisión Provincial por la Memoria desea analizar la información de los proyectos presentados en el programa
Jóvenes y Memoria durante la convocatoria 2020. Cada proyecto posee un código único, un título, el docente
coordinador (DNI, nombre y apellido, email), la cantidad de alumnos que participan del proyecto, el nombre de la
escuela y la localidad a la que pertenecen. Cada escuela puede presentar más de un proyecto. La información se
ingresa ordenada consecutivamente por localidad y, para cada localidad, por escuela. Realizar un programa que
lea la información de los proyectos hasta que se ingrese el proyecto con código -1 (que no debe procesarse), e
informe:
● Cantidad total de escuelas que participan en la convocatoria 2018 y cantidad de escuelas por cada localidad.
● Nombres de las dos escuelas con mayor cantidad de alumnos participantes.
● Título de los proyectos de la localidad de Daireaux cuyo código posee igual cantidad de dígitos pares e impares.

program Hello;
type 
    cadena20=string[20];
    coordinador=record
        dni:integer;
        nomyape:cadena20;
        email:cadena20;
    end;
    proyecto=record
        codigo:integer;
        titulo:cadena20;
        docente:coordinador;
        cantAlu:integer;
        escuela:cadena20;
        localidad:cadena20;
    end;
    
procedure leerCoordinador(var c:coordinador);
begin
  write('Ingrese DNI:');
  readln(c.dni);
  write('Ingrese el nombre y apellido:');
  readln(c.nomyape);
  write('Ingrese email:');
  readln(c.email);
end;
procedure leerProyecto(var p:proyecto);
var  c:coordinador;
begin
  write('Ingrese el codigo:');
  readln(p.codigo);
  if(p.codigo<>-1)then begin
    write('Ingrese el titulo:');
    readln(p.titulo);
    leerCoordinador(c);
    write('Ingrese la cantidad de alumno:');
    readln(p.cantAlu);
    write('Ingrese la escuela:');
    readln(p.escuela);
    write('Ingrese la localidad');
    readln(p.localidad);
  end;
end;
function iguales(codigo:integer):boolean;
var dig,par,impar:integer;
begin
  par:=0;
  impar:=0;
  while(codigo<>0)do begin
    dig:=codigo mod 10;
    if(dig mod 2=0)then
      par:=par+1
    else
      impar:=impar+1;
    codigo:=codigo div 10;
  end;
  iguales:=(par=impar);
end;
procedure maximoAlumnos(alumnos:integer;escuela:cadena20;var max1,max2:integer;var esc1,esc2:cadena20);
begin
  if(alumnos>max1)then begin
    max2:=max1;
    esc2:=esc1;
    max1:=alumnos;
    esc1:=escuela;
  end
  else if(alumnos>max2)then begin
    max2:=alumnos;
    esc2:=escuela;
  end;
end;
var p:proyecto;
    locActual,escActual,esc1,esc2:cadena20;
    cantEsc,cantLoc,cant,max1,max2:integer;
begin
  cantEsc:=0;
  max1:=-1;
  leerProyecto(p);
  while(p.codigo<>-1)do begin
    locActual:=p.localidad;
    cantEsc:=cantEsc+1;
    cantLoc:=0;
    while(p.codigo<>-1)and(locActual=p.localidad)do begin
      escActual:=p.escuela;
      cantLoc:=cantLoc+1;
      cant:=0;
      if(p.localidad='Daireaux')then begin
        if(iguales(p.codigo))then
          writeln('El tilo de proyecto co codigo igual cantidad de digitos pares e impares:',p.titulo);
      while (p.codigo<>-1)and(locActual=p.localidad)and(escActual=p.escuela)do begin
        cant:=cant+p.cantAlu;
        leerProyecto(p);
      end;
      maximoAlumnos(cant,p.escuela,max1,max2,esc1,esc2);
    end;
    writeln('Para la localidad ',locActual,' la cantidad de escuela es de:', cantLoc);
  end;
  writeln('Las dos escuelas con mas cantidad de alumnos son:',esc1,' con ',max1,' y ',esc2,' con ',max2);
end.

9. Realizar un programa que lea información de los candidatos ganadores de las últimas elecciones a intendente de
la provincia de Buenos Aires. Para cada candidato se lee: localidad, apellido del candidato, cantidad de votos
obtenidos y cantidad de votantes de la localidad. La lectura finaliza al leer la localidad ‘Zárate’, que debe procesarse.
Informar:
● El intendente que obtuvo la mayor cantidad de votos en la elección.
● El intendente que obtuvo el mayor porcentaje de votos de la elección.

program Hello;
type
    cadena30=string[30];
    candidato=record
         localidad:cadena30;
         apellido:cadena30;
         cantVotos:integer;
         cantVotantes:integer;
    end;
procedure leerCandidato(var c:candidato);
begin
  write('Ingrese la localidad:');
  readln(c.localidad);
  write('Ingrese el apellido:');
  readln(c.apellido);
  write('Ingrese la cantidad de votos:');
  readln(c.cantVotos);
  write('Ingrese la cantidad de votantes');
  readln(c.cantVotantes);
end;
procedure mayorCantVotos(cantVotos:integer;apellido:cadena30;var max:integer;maxApe:cadena30);
begin 
  if(cantVotos>max)then begin
    max:=cantVotos;
    maxApe:=apellido;
  end;
end;
function porcentaje(cantVotos:integer;totalVotos:integer):real;
begin
  porcentaje:=(cantVotos/totalVotos)*100;
end;
procedure mayorPorcentaje(porActual:real;apellido:cadena30;var maxP:real;var maxNom:cadena30);
begin
  if(porActual>maxP)then begin
    maxP:=porActual;
    maxNom:=apellido;
  end;
end;
var  
    can:candidato;
    max,cantTotalVotos:integer;
    maxP,porcentajeActual:real;
    maxApe,maxNom:cadena30;
begin
  max:=-1;
  maxP:=-1;
  cantTotalVotos:=0;
  repeat
    leerCandidato(can);
    cantTotalVotos:=cantTotalVotos+can.cantVotos;
    mayorCantVotos(can.cantVotos,can.apellido,max,maxApe);
    porcentajeActual:=porcentaje(can.cantVotos,cantTotalVotos);
    mayorPorcentaje(porcentajeActual,can.apellido,maxP,maxNom);
  until(can.localidad='Zarate');
  writeln('Intendente con mayor cantidad de votos:',maxApe);
  writeln('Intendente con mayor porcentaje de votos:',maxNom);
end.

10. Un centro de investigación de la UNLP está organizando la información de las 320 especies de plantas con las
que trabajan. Para cada especie se ingresa su nombre científico, tiempo promedio de vida (en meses), tipo de
planta (por ej. árbol, conífera, arbusto, helecho, musgo, etc.), clima (templado, continental, subtropical, desértico,
etc.) y países en el mundo donde se las encuentra. La información de las plantas se ingresa ordenada por tipo de
planta y, para cada planta, la lectura de países donde se las encuentra finaliza al ingresar el país 'zzz'. Al finalizar la
lectura, informar:
● El tipo de planta con menor cantidad de plantas.
● El tiempo promedio de vida de las plantas de cada tipo.
● El nombre científico de las dos plantas más longevas.
● Los nombres de las plantas nativas de Argentina que se encuentran en regiones con clima subtropical.
● El nombre de la planta que se encuentra en más países.

program Hello;
const
    PLANTS=3;//320
type
    cadena20=string[20];
    especie=record
        nombre:cadena20;
        tiempo:integer;
        tipo:cadena20;
        clima:cadena20;
        pais:cadena20;
    end;
procedure leerPlanta(var e:especie);
begin
  write('Ingrese el pais donde se las encuentra:');
  readln(e.pais);
  if(e.pais<>'zzz')then begin
    write('Ingrese el nombre cientifico:');
    readln(e.nombre);
    write('Ingrese el tiempo promedio de vida');
    readln(e.tiempo);
    write('Ingrese el tipo de planta');
    readln(e.tipo);
    write('Ingrese el clima');
    readln(e.clima);
  end;
end;
procedure menorCantPlantas(cantPlanta:integer;tipo:cadena20;var min:integer;var minTipo:cadena20);
begin
  if(cantPlanta<min)then begin
    min:=cantPlanta;
    minTipo:=tipo;
  end;
end;
function tiempoPromedio(cantPlanta:integer;cantVida:integer):real;
begin
  tiempoPromedio:=(cantVida/cantPlanta);
end;
procedure masLongevas(nombre:cadena20;cantVida:integer;var max1,max2:integer;var nom1,nom2:cadena20);
begin
  if(cantVida>max1)then begin
    max2:=max1;
    nom2:=nom1;
    max1:=cantVida;
    nom1:=nombre;
  end
  else if(cantVida>max2)then begin
    max2:=cantVida;
    nom2:=nombre;
  end;
end;
function nativasArg(pais,clima:cadena20):boolean;
begin
  nativasArg:=(pais='Argentina')and(clima='subtropical');
end;
procedure masPaises(nombre:cadena20;cantPaises:integer;var maxPaises:integer;var nomPaises:cadena20);
begin
  if(cantPaises>maxPaises)then begin
    maxPaises:=cantPaises;
    nomPaises:=nombre;
  end;
end;
var
    e:especie;
    i,max1,max2,min,cantPlanta,cantVida,maxPaises,cantPaises:integer;
    tipoActual,minTipo,paisActual,nom1,nom2,nomPaises:cadena20;
    resultado:real;
begin
  max1:=-1;
  min:=999;
  maxPaises:=0;
  for i:=1 to PLANTS do begin
    leerPlanta(e);
    while(e.pais<>'zzz')do begin
      tipoActual:=e.tipo;
      cantVida:=0;
      cantPlanta:=0;
      cantPaises:=0;
      while(e.pais<>'zzz')and(tipoActual=e.tipo)do begin
        paisActual:=e.pais;
        cantPaises:=cantPaises+1;
        masLongevas(e.nombre,e.tiempo,max1,max2,nom1,nom2);
        while(e.pais<>'zzz')and(paisActual=e.pais)do begin
          cantPlanta:=cantPlanta+1;
          cantVida:=cantVida+e.tiempo;
          if(nativasArg(e.pais;e.clima))then begin
            writeln('Plantas nativas de Arg en regiones subtropical:',e.nombre);
          end;
          leerPlanta(e);
        end;
        menorCantPlantas(cantPlanta,e.tipo,min,minTipo);
    end;
    masPaises(e.nombre,cantPaises,maxPaises,nomPaises);
    writeln(tiempoPromedio(cantPlanta,cantVida):4:2)
  end;
  writeln('El tipo de planta con menor cantidad de plantas:',minTipo);
  writeln('Nonmbre cientifico de las dos plantas mas longevas:',nom1,' y ',nom2);
  writeln('Nonmbre de la planta que se encuentra en mas paises',nomPaises);
end.

11. Una compañía de vuelos internacionales está analizando la información de todos los vuelos realizados por sus
aviones durante todo el año 2019. De cada vuelo se conoce el código de avión, país de salida, país de llegada,
cantidad de kilómetros recorridos y porcentaje de ocupación del avión. La información se ingresa ordenada por
código de avión y, para cada avión, por país de salida. La lectura finaliza al ingresar el código 44. Informar:
● Los dos aviones que más kilómetros recorrieron y los dos aviones que menos kilómetros recorrieron.
● El avión que salió desde más países diferentes.
● La cantidad de vuelos de más de 5.000 km que no alcanzaron el 60% de ocupación del avión.
● La cantidad de vuelos de menos de 10.000 km que llegaron a Australia o a Nueva Zelanda.

program Hello;
type cadena30=string[30];
     vuelo=record
        codigo:integer;
        salida:cadena30;
        destino:cadena30;
        cantkm:real;
        ocupacion:real;
     end;
procedure leerVuelo(var v:vuelo);
begin
  write('Ingrese codigo de avion:');
  readln(v.codigo);
  if (v.codigo<>44)then begin
    write('Ingrese pais de salida:');
    readln(v.salida);
    write('Ingrese pais de llegada:');
    readln(v.destino);
    write('Ingrese cantidad de kilometros recorridos:');
    readln(v.cantkm);
    write('Ingrese el porcentaje de ocupacion del avion:');
    readln(v.ocupacion);
  end;
end;
function masPaisesDiferentes(salida,destino:cadena30):boolean;
begin
  masPaisesDiferentes:=(salida<>destino);
end;

function masDeCincoMil(cantkm:real;ocupacion:real):boolean;
begin
  masDeCincoMil:=(cantkm>5000)and(ocupacion<60);
end;

function menosDeDiezMil(cantkm:real,destino:cadena30):boolean
begin
  menosDeDiezMil:=(cantkm=10000)and(destino='Australia')or(destino='Nueva Zelanda');
end;

procedure dosMaximos(codigo:integer;cantkm:real;var max1,max2:real;var codMax1,codMax2:integer);
begin
  if(cantkm>max1)then begin
    max2:=max1;
    codMax2:=codMax1;
    max1:=cantkm;
    codMax1:=codigo;
  end
  else if(cantkm>max2)then begin
          max2:=cantkm;
          codMax2:=codigo;
  end;
end;
procedure dosMinimos(codigo:integer;cantkm:real;var min1,min2:real;var codMin1,codMin2:integer);
begin
  if(cantkm<min1)then begin
    min2:=min1;
    codMin2:=codMin1;
    min1:=cantkm;
    codMin1:=codigo;
  end
  else if(cantkm<min2)then begin
          min2:=cantkm;
          codMin2:=codigo;
  end;
end;
var v:vuelo;
    max1,max2,min1,min2,cantKM:real;
    codMax1,codMax2,codMin1,codMin2,codActual,cantMasCinco,cantMenosDiez:integer;
    salidaActual:cadena30;
begin
  max1:=-1;
  min1:=999;
  codMax1:=0;
  codMin1:=0;
  cantMasCinco:=0;
  cantMenosDiez:=0;
  leerVuelo(v);
  while(v.codigo<>44)do begin
    codActual:=v.codigo;
    cantKM:=0;
    while(v.codigo<>44)and(codActual=v.codigo)do begin
      salidaActual:=v.salida;
      while(v.codigo<>44)and(salidaActual=v.salida)do begin
        cantKM:=cantKM+v.cantkm;
        if(masDeCincoMil(v.cantkm,v.ocupacion))then
          cantMasCinco:=cantMasCinco+1;
        if(menosDeDiezMilv.cantkm,v.destino)then
          menosDeDiezMil:=menosDeDiezMil+1;
        leerVuelo(v);
      end;
      if(masPaisesDiferentes(salidaActual,v.destino))then
        writeln('El avion que salio desde mas paises diferentes:',v.codigo);
    end;
    dosMaximos(v.codigo,cantKM,max1,max2,codMax1,codMax2);
    dosMinimos(v.codigo,cantKM,min1,min2,codMin1,codMin2);
  end;
  writeln('Los dos aviones que más kilómetros recorrieron:',codMax1,' y ',codMax2);
  writeln('Los dos aviones que menos kilómetros recorrieron:',codMin1,' y ',codMin2);
  writeln('La cantidad de vuelos de más de 5.000 km que no alcanzaron el 60% de ocupación del avión:',cantMasCinco);
  writeln ('La cantidad de vuelos de menos de 10.000 km que llegaron a Australia o a Nueva Zelanda:',cantMenosDiez);
end.
